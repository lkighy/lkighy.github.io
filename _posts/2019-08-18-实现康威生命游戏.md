---
title: 实现康威生命游戏
description: 在我们深入之前,我们有一些设计需要考虑.
categories:
  - rust/WebAssembly
tags: [rust, WebAssembly, 翻译]
---

## 设计

在我们深入之前,我们有一些设计需要考虑.

### 无限的 universe

生命游戏是在无限的 universe 中进行的,但我们没有无限的内存和计算能力.解决这个相当烦人的限制通常由一下三种选择:

1. 跟踪 universe 的哪个子集发生了有趣的事情,并根据需要扩展此区域.在最坏的情况下,这种扩展是无限制的,实现将变得越来越慢,,最终耗尽内存.
2. 创建固定大小的 universe ,其中边缘上的单元格比中间的单元格具有更少的邻居.这种方法缺点是达到 universe 尽头的无限的,如同滑翔机这样的到达了 universe 尽头,都会被消灭.
3. 创建一个固定大小固定周期的 universe ,其中边缘上的单元格连接着 universe 另一侧的单元格,因为连接临近的 universe ,滑翔机可以永远运行下去.

我们将实现第三种选择.

### 连接 Rust 和 JavaScript

> ⚡即便离开了本教程,这也是最重要的概念之一!

JavaScript 中的垃圾回收器(其中分配了 `object`, `array` 和 DOM 节点) 与 WebAssembly 的线性内存空间不同,后者存在于 Rust 值所在的空间.WebAssembly 目前无法直接访问垃圾回收器(截至 2018年 4月,预计会随着 ["webIDL bindings" 提案](https://github.com/WebAssembly/webidl-bindings/blob/master/proposals/webidl-bindings/Explainer.md)而改变).另一方面,JavaScript 可以读取和写入 WebAssembly 线性内存空间,但只能作为 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 的标量值(`u8`, `i32`, f64` 等等...).WebAssembly 函数也接受并返回标量值.这些是构成所有 WebAssembly 和 JavaScript 通信的构建块.

`wasm_bindgen` 定义了如何跨越此边界适用符合构建的共同协议.它涉及装箱 Rust 结构,将指针包装在 JavaScript 类中或从 Rust 索引到 JavaScript 对象表中以便使用.`wasm_bindgen` 非常方便,但它不需要我们考虑数据表示,以及跨越此边界传递的值和结构.相反,您可以将其视为实现所有界面设计的工具.

在设计 webAssembly 和 JavaScript 之间的接口时,我们希望针对一下属性进行优化:

1. **复制进入 WebAssembly 线性内存的将是最小化的.**不必要的副本会带来不必要的开销.
2. **最小序列化和反序列化.**与副本类似,序列化和反序列化也会产生开销,并且通常会造成复制.如果我们可以将不透明句柄传递给数据结构 - 而不是在一侧将其序列化,再复制到 WebAssembly 线性内存中的某个已知位置,并再另一侧进行反序列化 - 我们通常可以减少大量开销.`wasm_bindgen` 帮助我们定义可处理 JavaScript 对象或将 Rust 结构装入不透明句柄.

通常的经验时,良好的 JavaScript ↔ WebAssembly 接口设计通常时间大型的,长期存在的数据结构实现为驻留在 WebAssembly 的 Rust 类型,并将其作为不透明句柄暴露给 JavaScript .JavaScript 调用导出的 WebAssembly 函数,这些函数接受这些不透明句柄,转换数据,执行繁重的计算,查询数据,最终返回一个小的可复制的结果.通过返回计算的小小的结果,我们避免在 JavaScript 垃圾回收器 和 WebAssembly 线性内存之间来回复制/序列化所有内容.

### 在我们的生命游戏中连接 Rust 和 JavaScript

首先我们列举一些要避免的危险,我们不希望再每个 tick 上将整个 universe 复制到 WebAssembly 线性内存中.我们不希望为 universe 中每个单元分配对象,也不想强制进行跨边界调用来读写每个单元.

这会给我们留下什么?我们可以将 universe 表示为一个平面数组,它存在于 WebAssembly 线性内存中,每个单元都有一个字节.  0 是死细胞,1 是活细胞.

这是 4 × 4  universe 再内存中的样子:

![universe](https://rustwasm.github.io/book/images/game-of-life/universe.png)

要在  universe 中的给定行和列中查找单元格的数组索引,我们可以使用一下公式:

```text
index(row, column, universe) = row * width(universe) + column
```

我们有几种方法可以将 universe 的单元格暴露给 JavaScript.首先,我们将 `Universe` 实现 `std::fmt::Display`,我们可以使用它来生成呈现为文本字符的单元格 Rust String.然后将此 Rust String 从 WebAssembly 先行内存复制到 JavaScript 的垃圾回收器中的 JavaScript String 中,然后通过 设置 HTML textContent 显示.再本章的后面我们将改进这个实现,以避免再队之间复制 universe 的单元格渲染到 `<canvas>`(画布).

*另一个可行的设计代替方案是 Rust 返回每一个更改状态后的细胞的单元格刘表,而不是整个 universe 暴露给 JavScript.这样,JavaScript 在渲染时不需要遍历整个 universe, 只需要相关的子集.折中之处在于,这种基于 delta-based 设计更难实现.*

## Rust实现

在上一章中,我们克隆了一个初始项目模板.我们现在将修改该项目模板.

让我们首先从 `wasm-game-of-life/ssrc/lib.rs` 中删除 `alert` 模块和 `greet` 函数,然后定义单元格的类型替换它们:

```rust
#[wasm_bindgen]
#[repr(u8)]
#[derive(clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
```

重要的是我们有 `#[repr(u8)]`,因此每个单元格都被表示为一个字节.同样重要的是, `Dead` 变量为 `0`,`Alive` 变量为 `1`,这样我们就可以通过添加来轻松计算单元格活着的邻居.

接下来让我们定义 universe,universe 具有宽度和高度,以及 `width * height` 的长度的向量.

```rust
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}
```

要访问给定行和列的单元格,我们将行和列转换为单元格向量的索引,如前所述:

```rust
impl Universe {
    fn get_index(&self, row: u32, column: u32) -> usize {
        (row * self.width + column) as usize
    }

    // ...
}
```

为了计算单元格的下一状态,我们需要计算器邻居数量是多少.让我们编写一个 `live_neighbor_count` 方法来做到这一点!

```rust
impl Universe {
    // ...

    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 && delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
```

`live_neighobor_count` 方法使用 deltas 和取余的方法对 universe 边缘进行特殊包装来避免使用 `if`. 当 delta `-1` 时,我们添加 `self.height - 1` 并使用取余来完成这件事,而不是使用 `-1` . `row` 和 `column` 可以为零,如果我们试图让为 `0` 的它们减去 `1` ,则会出现无符号整数下溢.

现在我们拥有了从当前一代计算下一代所需要的一切!现在将游戏的每一个规则转换为 `match` 表达式上的条件.另外,我们希望 JavaScript 

现在我们拥有了从当前计算下一代所需的一切!游戏的每一个规则都遵循一个简单的转换为 `match` 表达式的条件.另外,我们希望 javaScript 通过 tick 控制发生的时间,因此我们会将此方法放在 `#[wasm_bindgen]` 块中,这样它就会暴露给 JavaScript.

```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x < 2 => Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x > 3 => Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) => Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) => otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}

```

到目前为止, Universe 细胞的状态被表现为 Vec.为了让其更容读,让我们实现一个基本的文本渲染器(text renderer).我们的想法时将 Universe 逐行写为文本,对于每个活细胞,我们将打印 Unicoe 字符 `◼`("黑色中等方块").对于死细胞,我们将打印`◻`("白色中等方块").

通过实现 Rust 标准库中 `Display` 的 trait, 我们可以添加一种以面向用户的方式的格式化结构的方法.这也会自动给我们一个 `to_string` 方法.

```rust

use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, "{}", symbol)?;
            }
            write!(f, "\n")?;
        }

        Ok(())
    }
}

```

最后,我们定义一个构造函数,用一个有趣的活细胞死细胞模式初始化宇宙,以及一个 `render` 方法:

```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -> Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&self) -> String {
        self.to_string()
    }
}
```

有了这个,我们 Rust 实现的生命游戏就完成一半了!

通过 `wasm-pack` 在 `wasm-game-of-life` 目录中运行将其重新编译为 WebAssembly.

## 使用 JavaScript 渲染

首先,让我们在 `wasm-game-of-life/www/index.html` 中添加一个 `<pre>` 元素来渲染 universe,就添加在 `<script>` 标签上方:

```html
<body>
  <pre id="game-of-life-canvas"></pre>
  <script src="./bootstrap.js"></script>
</body>
```

此外,我们希望 `<pre>` 居中在网页的中间.我们可以使用 CSS 弹性盒子来完成这项任务. 在 `wasm-game-of-life/www/index.html` 中 `head`标签添加 `<style>` 标签:

```html
<style>
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
</style>
```

在 `wasm-game-of-life/www/index.js` 的顶部,让我们导入的 `greet` 方法替换为 `Universe`:

```js
import { Universe } from "wasm-game-of-life";
```

另外,让我们为刚刚添加的 `<pre>` 元素实例化一个新的 Universe:

```js
const pre = document.getElementById("game-of-life-canvas");
const universe = Universe.new();
```

JavaScript 运行在一个 [`requestAnimationFrame` 循环中](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame).在每次迭代中,他将当前 Universe 绘制到 `<pre>` ,然后调用 `Universe::tick`.

```js
const renderLoop = () => {
    pre.textContent = universe.render()
    universe.tick();

    requestAnimationFrame(renderLoop);
}
```

要开始渲染过程前,我们还要为渲染循环的第一次迭代进行初始化调用:

```js
requestAnimationFrame(renderLoop);
```

未完待续...

- [**目录**](/rust/webassembly/2019/08/22/WebAssembly之书目录)
- 下一篇:[**测试康威生命游戏**](javascript:;)
- 上一篇:[**康威生命游戏规则**](/rust/webassembly/2019/07/13/康威生命游戏规则/)

---

- via: [https://rustwasm.github.io/book/game-of-life/implementing.html](https://rustwasm.github.io/book/game-of-life/implementing.html)
- 译者: lkighy
- 校对: -
